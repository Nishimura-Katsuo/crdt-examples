/* Second Simplest example of a CRDT - keeps positive/negative counts across multiple sites
 *
 * All CRDTs must adhere to three properties:
 * 	Merging nodes must be idempotent
 * 	Merging nodes must be associative
 * 	Merging nodes must be commutative
 */

class PNCounter {
	constructor (site = 'local') { // site can be a unique ID generated by the server, or even a UUID
		this.pCount = {};
		this.nCount = {};
		this.site = site;
	}

	add (num = 1) {
		if (num >= 0) {
			this.pCount[this.site] = (this.pCount[this.site] || 0) + num;
		} else {
			this.nCount[this.site] = (this.nCount[this.site] || 0) + num;
		}
	}

	getNodes () {
		return { pCount: this.pCount, nCount: this.nCount };
	}

	valueOf () {
		return Object.values(this.nCount).reduce((t, v) => t + v, 0) + Object.values(this.pCount).reduce((t, v) => t + v, 0);
		// this is where it satisfies associativity and commutativity, because addition has both properties
	}

	mergeNodes (nodes) {
		// This is where it satisfies idempotency, because you can merge the same nodes multiple times and it doesn't affect anything after the first time

		for (let site in nodes.pCount) {
			this.pCount[site] = Math.max(this.pCount[site] || 0, nodes.pCount[site]);
		}

		for (let site in nodes.nCount) {
			this.nCount[site] = Math.min(this.nCount[site] || 0, nodes.nCount[site]);
		}
	}
}

// site 1
let PNC1 = new PNCounter('GC1');
PNC1.add(-2);
console.log('PNC1:', PNC1.valueOf());

// site 2
let PNC2 = new PNCounter('PNC2');
PNC2.add(3);
console.log('PNC2:', PNC2.valueOf());

// servers exchange state at some point
let PNC1Nodes = PNC1.getNodes();
let PNC2Nodes = PNC2.getNodes();
console.log('State exchange...');
PNC2.mergeNodes(PNC1Nodes);
PNC1.mergeNodes(PNC2Nodes);

// which eventually results in the same stat
console.log('PNC1:', PNC1.valueOf());
console.log('PNC2:', PNC2.valueOf());
