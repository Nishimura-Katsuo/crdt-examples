/* Simplest example of a CRDT - keeps counts across multiple sites
 *
 * All CRDTs must adhere to three properties:
 * 	Merging nodes must be idempotent
 * 	Merging nodes must be associative
 * 	Merging nodes must be commutative
 */

class GCounter {
	constructor (site = 'local') { // site can be a unique ID generated by the server, or even a UUID
		this.pCount = {};
		this.site = site;
	}

	add (num = 1) {
		if (num < 0) {
			throw new Error('num must not be negative!');
		}

		this.pCount[this.site] = (this.pCount[this.site] || 0) + num;
	}

	getNodes () {
		return this.pCount;
	}

	valueOf () {
		// this is where it satisfies associativity and commutativity, because addition has both properties

		return Object.values(this.pCount).reduce((t, v) => t + v, 0);
	}

	mergeNodes (nodes) {
		for (let site in nodes) {
			// This is where it satisfies idempotency, because you can merge the same nodes multiple times and it doesn't affect anything after the first time

			this.pCount[site] = Math.max(this.pCount[site] || 0, nodes[site]); // this is a simple grow-only counter, so we take the largest of the two values
		}
	}
}

// site 1
let GC1 = new GCounter('GC1');
GC1.add(2);
console.log('GC1:', GC1.valueOf());

// site 2
let GC2 = new GCounter('GC2');
GC2.add(3);
console.log('GC2:', GC2.valueOf());

// servers exchange state at some point
let GC1Nodes = GC1.getNodes();
let GC2Nodes = GC2.getNodes();
console.log('State exchange...');
GC2.mergeNodes(GC1Nodes);
GC1.mergeNodes(GC2Nodes);

// which eventually results in the same stat
console.log('GC1:', GC1.valueOf());
console.log('GC2:', GC2.valueOf());
